// Generated by CoffeeScript 1.10.0
(function() {
  var Parser, Transposer,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Transposer = (typeof window !== "undefined" && window !== null ? window.Transposer : void 0) || require('../transposer/transposer').Transposer;

  (typeof window !== "undefined" && window !== null ? window : exports).Parser = Parser = (function() {
    function Parser(source) {
      this.source = source;
      this.processLine = bind(this.processLine, this);
    }

    Parser.prototype.parse = function() {
      this.processDirectives();
      if (this.attributes.tone) {
        this.transposer || (this.transposer = new Transposer(this.attributes.tone));
      }
      return {
        lines: this.source.split("\n").map(this.processLine).filter(function(l) {
          return l !== null;
        }),
        attributes: this.attributes
      };
    };

    Parser.prototype.processDirectives = function() {
      var ref;
      if (this.attributes) {
        return;
      }
      this.attributes = {};
      if ((ref = this.source.match(/{.*?}/g)) != null) {
        ref.forEach((function(_this) {
          return function(directive) {
            var key, ref1, value;
            ref1 = directive.slice(1, -1).split(':').map(function(d) {
              return d.trim();
            }), key = ref1[0], value = ref1[1];
            return _this.attributes[key.toLowerCase()] = value;
          };
        })(this));
      }
      return this.source = this.source.replace(/{.*?}/g, '');
    };

    Parser.prototype.processLine = function(line) {
      var chordExpr, chords, lyrics, normalized, ref, regex;
      line = line.trim();
      if (line === '' && this.lastProcessedLine === '') {
        return null;
      }
      this.lastProcessedLine = line;
      chordExpr = "\\[[A-G].*?\\]";
      regex = new RegExp(chordExpr, 'g');
      lyrics = line.split(regex);
      chords = (ref = line.match(regex)) != null ? ref.map(function(chord) {
        return chord.slice(1, -1).replace('b', '\u266d').replace('#', '\u266f');
      }) : void 0;
      if (new RegExp("^" + chordExpr).test(line)) {
        lyrics.shift();
      } else {
        if (chords != null) {
          chords.unshift('');
        }
      }
      if (chords && this.transposer) {
        normalized = chords.map((function(_this) {
          return function(chord) {
            return chord && _this.transposer.normalize(chord) || '';
          };
        })(this));
        if (this.transposer.to) {
          chords = chords.map((function(_this) {
            return function(chord) {
              return chord && _this.transposer.transpose(chord) || '';
            };
          })(this));
        }
      }
      return {
        chords: chords,
        lyrics: lyrics,
        normalized: normalized
      };
    };

    Parser.prototype.transposeTo = function(tone) {
      this.processDirectives();
      this.transposer = new Transposer(this.attributes.tone, tone);
      return this;
    };

    return Parser;

  })();

}).call(this);
